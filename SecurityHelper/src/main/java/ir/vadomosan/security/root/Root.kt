package ir.vadomosan.security.root

import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import android.util.Log
import ir.vadomosan.security.Const
import java.io.*
import java.util.*

/**
 * A simple root checker that gives an *indication* if the device is rooted or not.
 * Disclaimer: **root==god**, so there's no 100% way to check for root.
 */
class Root(private val mContext: Context) {
    private val loggingEnabled: Boolean = true

    /**
     * Run all the root detection checks.
     *
     * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
     */
    val isRooted: Boolean
        get() = (detectRootManagementApps() || detectPotentiallyDangerousApps() || checkForBinary(
            Const.BINARY_SU
        )
                || checkForDangerousProps() || checkForRWPaths()
                || detectTestKeys() || checkSuExists() || checkForRootNative() || checkForMagiskBinary())

    @get:Deprecated("This method is deprecated as checking without the busybox binary is now the\n" + "      default. This is because many manufacturers leave this binary on production devices.")
    val isRootedWithoutBusyBoxCheck: Boolean
        get() {
            return isRooted
        }

    /**
     * Run all the checks including checking for the busybox binary.
     * Warning: Busybox binary is not always an indication of root, many manufacturers leave this
     * binary on production devices
     *
     * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
     */
    val isRootedWithBusyBoxCheck: Boolean
        get() {
            return (detectRootManagementApps() || detectPotentiallyDangerousApps() || checkForBinary(
                Const.BINARY_SU
            )
                    || checkForBinary(Const.BINARY_BUSYBOX) || checkForDangerousProps() || checkForRWPaths()
                    || detectTestKeys() || checkSuExists() || checkForRootNative() || checkForMagiskBinary())
        }

    /**
     * Release-Keys and Test-Keys has to do with how the kernel is signed when it is compiled.
     * Test-Keys means it was signed with a custom key generated by a third-party developer.
     *
     * @return true if signed with Test-keys
     */
    fun detectTestKeys(): Boolean {
        val buildTags: String? = Build.TAGS
        return buildTags != null && buildTags.contains("test-keys")
    }
    /**
     * Using the PackageManager, check for a list of well known root apps. @link {Const.knownRootAppsPackages}
     *
     * @param additionalRootManagementApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    /**
     * Using the PackageManager, check for a list of well known root apps. @link {Const.knownRootAppsPackages}
     *
     * @return true if one of the apps it's installed
     */
    @JvmOverloads
    fun detectRootManagementApps(additionalRootManagementApps: Array<String?>? = null): Boolean {

        // Create a list of package names to iterate over from constants any others provided
        val packages: ArrayList<String> =
            ArrayList(Arrays.asList(*Const.knownRootAppsPackages))
        if (additionalRootManagementApps != null && additionalRootManagementApps.size > 0) {
            packages.addAll(Arrays.asList<String>(*additionalRootManagementApps))
        }
        return isAnyPackageFromListInstalled(packages)
    }
    /**
     * Using the PackageManager, check for a list of well known apps that require root. @link {Const.knownRootAppsPackages}
     *
     * @param additionalDangerousApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    /**
     * Using the PackageManager, check for a list of well known apps that require root. @link {Const.knownRootAppsPackages}
     *
     * @return true if one of the apps it's installed
     */
    @JvmOverloads
    fun detectPotentiallyDangerousApps(additionalDangerousApps: Array<String?>? = null): Boolean {

        // Create a list of package names to iterate over from constants any others provided
        val packages: ArrayList<String> = ArrayList()
        packages.addAll(Arrays.asList(*Const.knownDangerousAppsPackages))
        if (additionalDangerousApps != null && additionalDangerousApps.size > 0) {
            packages.addAll(Arrays.asList<String>(*additionalDangerousApps))
        }
        return isAnyPackageFromListInstalled(packages)
    }

    /**
     * Using the PackageManager, check for a list of well known root cloak apps. @link {Const.knownRootAppsPackages}
     * and checks for native library read access
     *
     * @return true if one of the apps it's installed
     */
    fun detectRootCloakingApps(): Boolean {
        return detectRootCloakingApps(null) || canLoadNativeLibrary() && !checkForNativeLibraryReadAccess()
    }

    /**
     * Using the PackageManager, check for a list of well known root cloak apps. @link {Const.knownRootAppsPackages}
     *
     * @param additionalRootCloakingApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    fun detectRootCloakingApps(additionalRootCloakingApps: Array<String?>?): Boolean {

        // Create a list of package names to iterate over from constants any others provided
        val packages: ArrayList<String> =
            ArrayList(Arrays.asList(*Const.knownRootCloakingPackages))
        if (additionalRootCloakingApps != null && additionalRootCloakingApps.size > 0) {
            packages.addAll(Arrays.asList<String>(*additionalRootCloakingApps))
        }
        return isAnyPackageFromListInstalled(packages)
    }

    /**
     * Checks various (Const.suPaths) common locations for the SU binary
     *
     * @return true if found
     */
    fun checkForSuBinary(): Boolean {
        return checkForBinary(Const.BINARY_SU)
    }

    /**
     * Checks various (Const.suPaths) common locations for the magisk binary (a well know root level program)
     *
     * @return true if found
     */
    fun checkForMagiskBinary(): Boolean {
        return checkForBinary("magisk")
    }

    /**
     * Checks various (Const.suPaths) common locations for the busybox binary (a well know root level program)
     *
     * @return true if found
     */
    fun checkForBusyBoxBinary(): Boolean {
        return checkForBinary(Const.BINARY_BUSYBOX)
    }

    /**
     * @param filename - check for this existence of this file
     * @return true if found
     */
    fun checkForBinary(filename: String): Boolean {
        val pathsArray: Array<String> =
            Const.getPaths()
        var result: Boolean = false
        for (path: String in pathsArray) {
            val completePath: String = path + filename
            val f: File = File(path, filename)
            val fileExists: Boolean = f.exists()
            if (fileExists) {
                Log.w("TAG", "$completePath binary detected!")
                result = true
            }
        }
        return result
    }

    private fun propsReader(): Array<String>? {
        try {
            val inputstream: InputStream? =
                Runtime.getRuntime().exec("getprop").inputStream
            if (inputstream == null) return null
            val propVal: String = Scanner(inputstream).useDelimiter("\\A").next()
            return propVal.split("\n".toRegex()).toTypedArray()
        } catch (e: IOException) {
            Log.w("TAG", e)
            return null
        } catch (e: NoSuchElementException) {
            Log.w("TAG", e)
            return null
        }
    }

    private fun mountReader(): Array<String>? {
        try {
            val inputstream: InputStream? =
                Runtime.getRuntime().exec("mount").inputStream
            if (inputstream == null) return null
            val propVal: String = Scanner(inputstream).useDelimiter("\\A").next()
            return propVal.split("\n".toRegex()).toTypedArray()
        } catch (e: IOException) {
            Log.w("TAG", e)
            return null
        } catch (e: NoSuchElementException) {
            Log.w("TAG", e)
            return null
        }
    }

    /**
     * Check if any package in the list is installed
     *
     * @param packages - list of packages to search for
     * @return true if any of the packages are installed
     */
    private fun isAnyPackageFromListInstalled(packages: List<String>): Boolean {
        var result: Boolean = false
        val pm: PackageManager = mContext.packageManager
        for (packageName: String in packages) {
            try {
                // Root app detected
                pm.getPackageInfo(packageName, 0)
                Log.w("TAG", "$packageName ROOT management app detected!")
                result = true
            } catch (e: PackageManager.NameNotFoundException) {
                // Exception thrown, package is not installed into the system
            }
        }
        return result
    }

    /**
     * Checks for several system properties for
     *
     * @return - true if dangerous props are found
     */
    fun checkForDangerousProps(): Boolean {
        val dangerousProps: MutableMap<String, String> =
            HashMap()
        dangerousProps["ro.debuggable"] = "1"
        dangerousProps["ro.secure"] = "0"
        var result: Boolean = false
        val lines: Array<String>? = propsReader()
        if (lines == null) {
            // Could not read, assume false;
            return false
        }
        for (line: String in lines) {
            for (key: String in dangerousProps.keys) {
                if (line.contains(key)) {
                    var badValue: String? = dangerousProps.get(key)
                    badValue = "[$badValue]"
                    if (line.contains(badValue)) {
                        Log.w("TAG", "$key = $badValue detected!")
                        result = true
                    }
                }
            }
        }
        return result
    }

    /**
     * When you're root you can change the permissions on common system directories, this method checks if any of these patha Const.pathsThatShouldNotBeWritable are writable.
     *
     * @return true if one of the dir is writable
     */
    fun checkForRWPaths(): Boolean {
        var result: Boolean = false

        //Run the command "mount" to retrieve all mounted directories
        val lines: Array<String>? = mountReader()
        if (lines == null) {
            // Could not read, assume false;
            return false
        }

        //The SDK version of the software currently running on this hardware device.
        val sdkVersion: Int = Build.VERSION.SDK_INT
        /**
         *
         * In devices that are running Android 6 and less, the mount command line has an output as follow:
         *
         * <fs_spec_path> <fs_file> <fs_spec> <fs_mntopts>
         *
         * where :
         * - fs_spec_path: describes the path of the device or remote filesystem to be mounted.
         * - fs_file: describes the mount point for the filesystem.
         * - fs_spec describes the block device or remote filesystem to be mounted.
         * - fs_mntopts: describes the mount options associated with the filesystem. (E.g. "rw,nosuid,nodev" )
         *
        </fs_mntopts></fs_spec></fs_file></fs_spec_path> */
        /** In devices running Android which is greater than Marshmallow, the mount command output is as follow:
         *
         * <fs_spec> <ON> <fs_file> <TYPE> <fs_vfs_type> <(fs_mntopts)>
         *
         * where :
         * - fs_spec describes the block device or remote filesystem to be mounted.
         * - fs_file: describes the mount point for the filesystem.
         * - fs_vfs_type: describes the type of the filesystem.
         * - fs_mntopts: describes the mount options associated with the filesystem. (E.g. "(rw,seclabel,nosuid,nodev,relatime)" )
        </fs_vfs_type></TYPE></fs_file></ON></fs_spec> */
        for (line: String in lines) {

            // Split lines into parts
            val args: Array<String> = line.split(" ".toRegex()).toTypedArray()
            if (((sdkVersion <= Build.VERSION_CODES.M && args.size < 4)
                        || (sdkVersion > Build.VERSION_CODES.M && args.size < 6))
            ) {
                // If we don't have enough options per line, skip this and log an error
                Log.w("TAG", "Error formatting mount line: $line")
                continue
            }
            var mountPoint: String
            var mountOptions: String
            /**
             * To check if the device is running Android version higher than Marshmallow or not
             */
            if (sdkVersion > Build.VERSION_CODES.M) {
                mountPoint = args.get(2)
                mountOptions = args.get(5)
            } else {
                mountPoint = args.get(1)
                mountOptions = args.get(3)
            }
            for (pathToCheck: String in Const.pathsThatShouldNotBeWritable) {
                if (mountPoint.equals(pathToCheck, ignoreCase = true)) {
                    /**
                     * If the device is running an Android version above Marshmallow,
                     * need to remove parentheses from options parameter;
                     */
                    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
                        mountOptions = mountOptions.replace("(", "")
                        mountOptions = mountOptions.replace(")", "")
                    }

                    // Split options out and compare against "rw" to avoid false positives
                    for (option: String in mountOptions.split(",".toRegex())
                        .toTypedArray()) {
                        if (option.equals("rw", ignoreCase = true)) {
                            Log.w(
                                "TAG",
                                "$pathToCheck path is mounted with rw permissions! $line"
                            )
                            result = true
                            break
                        }
                    }
                }
            }
        }
        return result
    }

    /**
     * A variation on the checking for SU, this attempts a 'which su'
     *
     * @return true if su found
     */
    fun checkSuExists(): Boolean {
        var process: Process? = null
        try {
            process = Runtime.getRuntime().exec(
                arrayOf(
                    "which",
                    Const.BINARY_SU
                )
            )
            val `in`: BufferedReader =
                BufferedReader(InputStreamReader(process.getInputStream()))
            return `in`.readLine() != null
        } catch (t: Throwable) {
            return false
        } finally {
            if (process != null) process.destroy()
        }
    }

    /**
     * Checks if device has ReadAccess to the Native Library
     * Precondition: canLoadNativeLibrary() ran before this and returned true
     *
     *
     * Description: RootCloak automatically blocks read access to the Native Libraries, however
     * allows for them to be loaded into memory. This check is an indication that RootCloak is
     * installed onto the device.
     *
     * @return true if device has Read Access | false if UnsatisfiedLinkError Occurs
     */
    fun checkForNativeLibraryReadAccess(): Boolean {
        val rootNative: RootNative =
            RootNative()
        try {
            rootNative.setLogDebugMessages(loggingEnabled)
            return true
        } catch (e: UnsatisfiedLinkError) {
            return false
        }
    }

    /**
     * Checks if it is possible to load our native library
     *
     * @return true if we can | false if not
     */
    fun canLoadNativeLibrary(): Boolean {
        return RootNative().wasNativeLibraryLoaded()
    }

    /**
     * Native checks are often harder to cloak/trick so here we call through to our native root checker
     *
     * @return true if we found su | false if not, or the native library could not be loaded / accessed
     */
    fun checkForRootNative(): Boolean {
        if (!canLoadNativeLibrary()) {
            Log.w("TAG", "We could not load the native library to test for root")
            return false
        }
        val paths: Array<String> =
            Const.getPaths()
        val checkPaths: Array<String?> = arrayOfNulls(paths.size)
        for (i in checkPaths.indices) {
            checkPaths[i] =
                paths.get(i) + Const.BINARY_SU
        }
        val rootNative: RootNative =
            RootNative()
        try {
            rootNative.setLogDebugMessages(loggingEnabled)
            return rootNative.checkForRoot(checkPaths) > 0
        } catch (e: UnsatisfiedLinkError) {
            return false
        }
    }

}